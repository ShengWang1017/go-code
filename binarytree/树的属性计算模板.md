# 树的属性计算 - 通用模板

**思维路径**：
```
题目要求 → 是否需要子树信息 → 后序遍历 → 套用模板 → 调整三要素
```

## 核心思想

通过**后序遍历**（左 → 右 → 根）递归计算树的各种属性，答案由子树结果**自底向上递推**得出。

---

## 通用代码模板

```go
func treeProperty(root *TreeNode) ResultType {
    // 1. Base Case（递归终止条件）
    if root == nil {
        return baseValue  // 根据题意返回：0、nil、true/false 等
    }

    // 2. 递归处理左右子树
    leftResult := treeProperty(root.Left)
    rightResult := treeProperty(root.Right)

    // 3. 合并左右结果 + 当前节点贡献
    currentResult := merge(leftResult, rightResult, root.Val)

    return currentResult
}
```

---

## 三要素变化表

| 题目 | Base Case | 合并方式 | 当前节点贡献 | 复杂度 |
|------|-----------|----------|--------------|--------|
| **最大深度 (LC104)** | `0` | `max(left, right)` | `+1` | O(n) / O(h) |
| **最小深度 (LC111)** | `0` (需特判叶子) | `min(left, right)` | `+1` | O(n) / O(h) |
| **节点和** | `0` | `left + right` | `+ root.Val` | O(n) / O(h) |
| **路径和存在性** | `false` | `left \|\| right` | 判断 `sum == target` | O(n) / O(h) |

> 复杂度说明：时间 O(n) 遍历所有节点，空间 O(h) 递归栈深度（h 为树高）

---

## 识别特征

当题目满足以下条件时，可套用此模板：

1. ✅ 需要遍历整棵树
2. ✅ 答案可以从子树答案**递推**得出
3. ✅ 后序遍历（先处理子树，再处理当前节点）

---

## 示例：LC104 - 二叉树的最大深度

### 题意
给定二叉树，返回其最大深度（从根节点到最远叶子节点的最长路径节点数）。

### 代码实现

```go
func MaxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }

    leftMax := MaxDepth(root.Left)
    rightMax := MaxDepth(root.Right)

    // 优化：避免 math.Max 的类型转换
    if leftMax > rightMax {
        return leftMax + 1
    }
    return rightMax + 1
}
```

### 复杂度分析
- **时间复杂度**：O(n)，每个节点访问一次
- **空间复杂度**：O(h)，递归栈深度等于树高
  - 最坏情况（链式树）：O(n)
  - 最好情况（完全平衡树）：O(log n)

---

## 举一反三 - 推荐练习

### 同类型题目

1. **LC 111** - 二叉树的最小深度
   - 注意：需要特判叶子节点（单侧子树为空时不能直接取 min）

2. **LC 543** - 二叉树的直径
   - 思考：直径 = 左子树深度 + 右子树深度

3. **LC 124** - 二叉树中的最大路径和
   - 进阶：需要维护两个值（向上传递 vs 全局最优）

### 变体思路

- **自顶向下**：携带参数向下传递（前序遍历）
- **自底向上**：通过返回值向上汇总（后序遍历）← 本模板

---


## 总结

**关键点**：
1. 明确递归的**三要素**（base case、递归关系、返回值含义）
2. 识别题目是否可以**自底向上递推**
3. 灵活调整**合并方式**和**节点贡献**


